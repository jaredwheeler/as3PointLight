package  {	import flash.display.*;	import flash.events.*;	import flash.geom.Point;		public class PointLight {				private var _pos		:Point;		//position of light on gamebaord		private var _r			:uint; 		//red value - 0-255		private var _g			:uint; 		//green value - 0-255		private var _b			:uint; 		//blue value - 0-255		private var _radius		:Number; 	//radius in pixels of light		private var _intensity	:Number; 	//brightness of light - 0-1		private var _flicker	:Number; 	//amount of random flicker - 0-1		public function PointLight( pos:Point, r:uint, g:uint, b:uint, radius:Number, intensity:Number, flicker:Number = 0 )		{			_pos = pos;			_r = r;			_g = g;			_b = b;			_radius = radius;			_intensity = intensity;			_flicker = flicker;		}				public function update( )		{					}				public function renderInto( bd:BitmapData )		{			//make render bounds			var left:Number = Math.max( 0, _pos.x - _radius );			var right:Number = Math.min( bd.width, _pos.x + _radius );			var top:Number = Math.max( 0, _pos.y - _radius );			var bottom:Number = Math.min( bd.height, _pos.y + _radius );						//loop through all pixels in render bounds, applying light algorithm			var hyp:Number; //hypotenuse - distance from current pixel x,y to light's center x,y			var csub:Number, coeff:Number; //intensity coefficient - how much of the point light is applied to each pixel in bounds			var rsub:uint, gsub:uint, bsub:uint; //holders for discreet rgb vals during operation			var pixelColor:uint; //holder for combined color val						var flickerCoeff = 1 - Math.random( ) * _flicker						for( var y=top; y<bottom; y++ )			{				for( var x=left; x<right; x++ )				{					hyp = Math.min( Math.sqrt( (_pos.x-x)*(_pos.x-x) + (_pos.y-y)*(_pos.y-y) ), _radius ); //calculate the hypotenuse for this pixel					csub = Math.cos( Math.PI * ( hyp / _radius ) ) / 2 + 0.5; //approximate a gaussian curve with a cosine					coeff =  csub * _intensity * flickerCoeff; //intensity coefficient for this pixel					pixelColor = bd.getPixel(x,y); //grab pixel color at x,y					rsub = pixelColor >> 16 & 0xFF; //separate rbg out to discreet vals					gsub = pixelColor >> 8 & 0xFF;					bsub = pixelColor & 0xFF;					rsub = Math.min( rsub + (_r * coeff), 255 ); //do additive coor math					gsub = Math.min( gsub + (_g * coeff), 255 );					bsub = Math.min( bsub + (_b * coeff), 255 );					pixelColor = ( rsub << 16 ) | ( gsub << 8 ) | bsub; //re-combine discreet rgb channels					bd.setPixel( x, y, pixelColor ); //set pixel				}			}		}	}	}